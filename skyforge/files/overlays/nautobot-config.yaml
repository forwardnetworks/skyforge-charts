apiVersion: v1
kind: ConfigMap
metadata:
  name: nautobot-config
data:
  nautobot_config.py: |
    from nautobot.core.settings import *  # noqa

    import os


    def _split_csv(value: str) -> list[str]:
        return [item.strip() for item in value.split(",") if item.strip()]

    def _read_secret(env_key: str) -> str:
        file_path = os.getenv(f"{env_key}_FILE", "").strip()
        if file_path and os.path.exists(file_path):
            with open(file_path, "r", encoding="utf-8") as handle:
                return handle.read().strip()
        return os.getenv(env_key, "").strip()


    def _env_bool(key: str, default: bool = False) -> bool:
        value = os.getenv(key)
        if value is None:
            return default
        return value.strip().lower() in {"1", "true", "yes", "y", "on"}

    def _normalize_django_ldap_dn_template(template: str) -> str:
        template = template.strip()
        if "%(user)" in template:
            return template
        if "%s" in template:
            return template.replace("%s", "%(user)s")
        return template


    _public_hostnames = _split_csv(
        os.getenv("SKYFORGE_HOSTNAME", "")
    )
    _allow_any_hosts = _env_bool("SKYFORGE_ALLOW_ANY_HOSTS", True)

    # Serve at root; Traefik strips /nautobot before proxying.
    USE_X_FORWARDED_HOST = True
    USE_X_FORWARDED_PORT = True
    CSRF_TRUSTED_ORIGINS = [f"https://{hostname}" for hostname in _public_hostnames]
    STATIC_URL = "/static/"
    MEDIA_URL = "/media/"
    SESSION_COOKIE_PATH = "/"
    CSRF_COOKIE_PATH = "/"
    ALLOWED_HOSTS = ["*"] if _allow_any_hosts else [*_public_hostnames, "127.0.0.1", "localhost"]
    SECURE_SSL_REDIRECT = True
    SECURE_PROXY_SSL_HEADER = ("HTTP_X_FORWARDED_PROTO", "https")
    SESSION_COOKIE_SECURE = True
    CSRF_COOKIE_SECURE = True
    SECURE_HSTS_SECONDS = 31536000
    SECURE_HSTS_INCLUDE_SUBDOMAINS = False
    SECURE_HSTS_PRELOAD = False

    # Skyforge SSO (via Traefik forwardAuth + Remote-User headers).
    #
    # Nautobot has built-in support for remote header auth. It is enabled when
    # `nautobot.core.authentication.RemoteUserBackend` is present in
    # `AUTHENTICATION_BACKENDS`.
    if _env_bool("SKYFORGE_SSO_ENABLED", True):
        REMOTE_AUTH_ENABLED = True
        REMOTE_AUTH_AUTO_CREATE_USER = True
        REMOTE_AUTH_HEADER = "HTTP_REMOTE_USER"

        AUTHENTICATION_BACKENDS = (
            "nautobot.core.authentication.RemoteUserBackend",
            "nautobot.core.authentication.ObjectPermissionBackend",
            "django.contrib.auth.backends.ModelBackend",
        )

        try:
            from django.contrib.auth.signals import user_logged_in
            from django.dispatch import receiver

            @receiver(user_logged_in)
            def _skyforge_apply_rbac(sender, user, request, **kwargs):
                if user is None or not getattr(user, "is_authenticated", False):
                    return

                from django.contrib.auth.models import Group
                from django.contrib.contenttypes.models import ContentType
                from nautobot.tenancy.models import Tenant
                from nautobot.users.models import ObjectPermission

                group, _ = Group.objects.get_or_create(name="skyforge-users")
                username = getattr(user, "username", "") or ""
                tenant, _ = Tenant.objects.get_or_create(
                    name=username or "user",
                    defaults={
                        "description": "Skyforge per-user tenant",
                    },
                )

                types = []
                for label in ["ipam.ipaddress", "ipam.prefix", "dcim.device", "dcim.interface"]:
                    app_label, model = label.split(".", 1)
                    try:
                        types.append(ContentType.objects.get(app_label=app_label, model=model))
                    except ContentType.DoesNotExist:
                        continue

                perm_add, _ = ObjectPermission.objects.get_or_create(
                    name="Skyforge Users: add",
                    defaults={
                        "enabled": True,
                        "actions": ["add"],
                        "constraints": [],
                    },
                )
                perm_add.enabled = True
                perm_add.actions = ["add"]
                perm_add.constraints = []
                perm_add.save()
                perm_add.groups.add(group)
                if types:
                    perm_add.object_types.set(types)

                perm_edit, _ = ObjectPermission.objects.get_or_create(
                    name="Skyforge Users: tenant edit",
                    defaults={
                        "enabled": True,
                        "actions": ["change", "delete"],
                        "constraints": [
                            {"tenant_id": str(tenant.id)},
                            {"device__tenant_id": str(tenant.id)},
                        ],
                    },
                )
                perm_edit.enabled = True
                perm_edit.actions = ["change", "delete"]
                perm_edit.constraints = [
                    {"tenant_id": str(tenant.id)},
                    {"device__tenant_id": str(tenant.id)},
                ]
                perm_edit.save()
                perm_edit.groups.add(group)
                if types:
                    perm_edit.object_types.set(types)

                user.groups.add(group)
        except Exception:
            pass

    # LDAP auth (optional; enabled when SKYFORGE_LDAP_URL(_FILE) and SKYFORGE_LDAP_BIND_TEMPLATE(_FILE) are set).
    _ldap_url = _read_secret("SKYFORGE_LDAP_URL")
    _ldap_bind_template = _read_secret("SKYFORGE_LDAP_BIND_TEMPLATE")

    if _ldap_url and _ldap_bind_template:
        import ldap  # type: ignore

        AUTHENTICATION_BACKENDS = (
            "django_auth_ldap.backend.LDAPBackend",
            *AUTHENTICATION_BACKENDS,
        )

        AUTH_LDAP_SERVER_URI = _ldap_url
        AUTH_LDAP_USER_DN_TEMPLATE = _normalize_django_ldap_dn_template(_ldap_bind_template)
        AUTH_LDAP_BIND_AS_AUTHENTICATING_USER = True
        AUTH_LDAP_START_TLS = _env_bool("SKYFORGE_LDAP_STARTTLS", False)

        AUTH_LDAP_CONNECTION_OPTIONS = {
            ldap.OPT_REFERRALS: 0,
        }
        if _env_bool("SKYFORGE_LDAP_SKIP_TLS_VERIFY", False):
            AUTH_LDAP_CONNECTION_OPTIONS.update(
                {
                    ldap.OPT_X_TLS_REQUIRE_CERT: ldap.OPT_X_TLS_NEVER,
                }
            )

        AUTH_LDAP_ALWAYS_UPDATE_USER = True
        AUTH_LDAP_USER_ATTR_MAP = {
            "first_name": "givenName",
            "last_name": "sn",
            "email": "mail",
        }
