apiVersion: v1
kind: ConfigMap
metadata:
  name: netbox-config
data:
  extra.py: |
    import json
    import os


    def read_file(path: str) -> str:
        if not path:
            return ""
        try:
            with open(path, "r", encoding="utf-8") as handle:
                return handle.read().strip()
        except OSError:
            return ""


    def truthy(value: str) -> bool:
        return str(value or "").strip().lower() in {"1", "true", "yes", "on"}

    raw_base_path = os.getenv("SKYFORGE_NETBOX_BASE_PATH", "netbox/").strip()
    if raw_base_path:
        BASE_PATH = raw_base_path if raw_base_path.endswith("/") else f"{raw_base_path}/"
        csrf_path = f"/{BASE_PATH.rstrip('/')}"
        CSRF_COOKIE_PATH = csrf_path
        SESSION_COOKIE_PATH = csrf_path
        CSRF_COOKIE_SECURE = True

    raw_host = os.getenv("SKYFORGE_HOSTNAME", "").strip()
    if raw_host:
        CSRF_TRUSTED_ORIGINS = [
            f"https://{host.strip()}"
            for host in raw_host.replace(",", " ").split()
            if host.strip()
        ]

    raw_token_peppers = os.getenv("API_TOKEN_PEPPERS", "").strip()
    if raw_token_peppers:
        try:
            parsed = json.loads(raw_token_peppers)
        except json.JSONDecodeError:
            parsed = [value.strip() for value in raw_token_peppers.split(",") if value.strip()]
        if isinstance(parsed, dict):
            converted = {}
            for key, value in parsed.items():
                try:
                    int_key = int(key)
                except (TypeError, ValueError):
                    continue
                if isinstance(value, (list, tuple)):
                    value = value[0] if value else ""
                converted[int_key] = str(value) if value is not None else ""
            API_TOKEN_PEPPERS = converted
        else:
            if isinstance(parsed, (list, tuple)):
                parsed = parsed[0] if parsed else ""
            API_TOKEN_PEPPERS = {1: str(parsed) if parsed is not None else ""}


    ldap_url = read_file(os.getenv("SKYFORGE_LDAP_URL_FILE", "").strip()) or os.getenv("SKYFORGE_LDAP_URL", "").strip()
    remote_auth_enabled = truthy(os.getenv("SKYFORGE_SSO_ENABLED", "true"))
    oidc_discovery_url = read_file(os.getenv("SKYFORGE_OIDC_DISCOVERY_URL_FILE", "").strip()) or os.getenv(
        "SKYFORGE_OIDC_DISCOVERY_URL", ""
    ).strip()
    oidc_client_id = read_file(os.getenv("SKYFORGE_OIDC_CLIENT_ID_FILE", "").strip()) or os.getenv(
        "SKYFORGE_OIDC_CLIENT_ID", ""
    ).strip()
    oidc_client_secret = read_file(os.getenv("SKYFORGE_OIDC_CLIENT_SECRET_FILE", "").strip()) or os.getenv(
        "SKYFORGE_OIDC_CLIENT_SECRET", ""
    ).strip()
    oidc_enabled = bool(oidc_discovery_url and oidc_client_id and oidc_client_secret)

    if remote_auth_enabled:
        REMOTE_AUTH_ENABLED = True
        REMOTE_AUTH_AUTO_CREATE_USER = True
        REMOTE_AUTH_HEADER = "HTTP_REMOTE_USER"
        REMOTE_AUTH_DEFAULT_GROUPS = ["skyforge-users"]
        REMOTE_AUTH_AUTO_CREATE_GROUPS = True
        AUTHENTICATION_BACKENDS = [
            "netbox.authentication.RemoteUserBackend",
            "django.contrib.auth.backends.ModelBackend",
        ]
        try:
            from django.contrib.auth.signals import user_logged_in
            from django.dispatch import receiver

            @receiver(user_logged_in)
            def _skyforge_apply_rbac(sender, user, request, **kwargs):
                if user is None or not getattr(user, "is_authenticated", False):
                    return

                from core.models import ObjectType
                from tenancy.models import Tenant
                from users.models import Group, ObjectPermission

                group, _ = Group.objects.get_or_create(name="skyforge-users")
                username = getattr(user, "username", "") or ""
                slug = "".join([c.lower() if c.isalnum() else "-" for c in username]).strip("-") or "user"
                tenant, _ = Tenant.objects.get_or_create(
                    slug=slug,
                    defaults={
                        "name": username or slug,
                        "description": "Skyforge per-user tenant",
                    },
                )

                types = []
                for label in ["ipam.ipaddress", "ipam.prefix", "dcim.device", "dcim.interface", "dcim.cable"]:
                    app_label, model = label.split(".", 1)
                    try:
                        types.append(ObjectType.objects.get(app_label=app_label, model=model))
                    except ObjectType.DoesNotExist:
                        continue

                perm_add, _ = ObjectPermission.objects.get_or_create(
                    name="Skyforge Users: add",
                    defaults={
                        "enabled": True,
                        "actions": ["add"],
                        "constraints": [],
                    },
                )
                perm_add.enabled = True
                perm_add.actions = ["add"]
                perm_add.constraints = []
                perm_add.save()
                perm_add.groups.add(group)
                if types:
                    perm_add.object_types.set(types)

                perm_edit, _ = ObjectPermission.objects.get_or_create(
                    name="Skyforge Users: tenant edit",
                    defaults={
                        "enabled": True,
                        "actions": ["change", "delete"],
                        "constraints": [
                            {"tenant_id": tenant.id},
                            {"device__tenant_id": tenant.id},
                        ],
                    },
                )
                perm_edit.enabled = True
                perm_edit.actions = ["change", "delete"]
                perm_edit.constraints = [
                    {"tenant_id": tenant.id},
                    {"device__tenant_id": tenant.id},
                ]
                perm_edit.save()
                perm_edit.groups.add(group)
                if types:
                    perm_edit.object_types.set(types)

                user.groups.add(group)
        except Exception:
            pass

    if oidc_enabled and not remote_auth_enabled:
        oidc_endpoint = oidc_discovery_url
        suffix = "/.well-known/openid-configuration"
        if oidc_endpoint.endswith(suffix):
            oidc_endpoint = oidc_endpoint[: -len(suffix)]

        AUTHENTICATION_BACKENDS = [
            "social_core.backends.open_id_connect.OpenIdConnectAuth",
            "django.contrib.auth.backends.ModelBackend",
        ]
        SOCIAL_AUTH_ENABLED = True
        SOCIAL_AUTH_BACKEND_PREFIX = "social_core.backends"
        SOCIAL_AUTH_OIDC_OIDC_ENDPOINT = oidc_endpoint
        SOCIAL_AUTH_OIDC_KEY = oidc_client_id
        SOCIAL_AUTH_OIDC_SECRET = oidc_client_secret
        SOCIAL_AUTH_OIDC_SCOPE = ["openid", "profile", "email", "groups"]
        SOCIAL_AUTH_OIDC_USERNAME_KEY = "preferred_username"
        SOCIAL_AUTH_OIDC_EMAIL_KEY = "email"
        SOCIAL_AUTH_REDIRECT_IS_HTTPS = True
        SOCIAL_AUTH_OIDC_VERIFY_SSL = False
    if ldap_url and not oidc_enabled and not remote_auth_enabled:
        # NetBox derives Django's AUTHENTICATION_BACKENDS from REMOTE_AUTH_BACKEND.
        # Override REMOTE_AUTH_BACKEND so LDAP credentials entered into the NetBox
        # login form are validated via the built-in LDAP backend, while preserving
        # local admin logins via ModelBackend.
        if "AUTHENTICATION_BACKENDS" not in globals():
            AUTHENTICATION_BACKENDS = [
                "netbox.authentication.LDAPBackend",
                "django.contrib.auth.backends.ModelBackend",
            ]
        REMOTE_AUTH_BACKEND = [
            "netbox.authentication.LDAPBackend",
            "django.contrib.auth.backends.ModelBackend",
        ]
        AUTH_LDAP_START_TLS = truthy(os.getenv("SKYFORGE_LDAP_STARTTLS", "false"))
        REMOTE_AUTH_ENABLED = False

        ldap_config_path = "/etc/netbox/config/ldap/ldap_config.py"
        try:
            with open(ldap_config_path, "r", encoding="utf-8") as handle:
                exec(handle.read(), globals())  # noqa: S102
        except OSError:
            pass
